

细粒度锁可以提高并行度，是性能优化的一个重要手段。但是可能会导致死锁。

死锁: 一组相互竞争资源的线程因为互相等待，导致"永久"阻塞的现象。

 如何预防死锁:
   死锁发生的条件:
    1. 互斥，共享资源X 和 Y 只能被一个线程占用;
    2. 占有且等待，线程A 已经取得共享资源X ，在等待共享资源Y的时候，不释放共享资源X；
    3. 不可抢占，其他线程不能强行抢占线程A占有的资源;
    4. 循环等待，线程A等待线程B占有的资源，线程B在等待线程A占有的资源，就是循环等待。
    也就是说，我们只需要破坏其中一个条件，就可以成功的避免死锁。

    其中，互斥这个条件是没有办法破坏的，因为我们用锁为的就是互斥。

    1. 对于占有且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
    2. 对于不可抢占这个条件，我们可以当占有部分资源的线程进一步申请其他资源时，如果申请不到，就主动释放它占有的资源。(synchronized 申请不到就阻塞了，不能主动释放。Lock可以)
    3. 对于循环等待这个条件，可以靠按某种顺序来申请资源来预防。申请的时候可以先申请序号小的，再申请序号大的。(成本最低的方案)


