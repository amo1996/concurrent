
导致可见性的原因是缓存，导致有序性的原因是编译优化。可是为了我们程序的性能，我们不能直接禁用缓存和编译优化。

合理的方案应该是按需禁用缓存以及编译优化。

Java内存模型规范了JVM如何提供按需禁用缓存和编译优化的方法。包括volatile synchronized 和final 三个关键字。以及六项Happens-Before规则。

为什么定义Java内存模型?
 现代计算机大部分是采用多处理器体系结构。每个处理器都有独立的寄存器和缓存。多个处理器可同时执行同一个进程中的不同线程，这里称为处理器的乱序执行。
 在Java中，不同的线程可能访问同一个共享变量。如果任由编译器或处理器对这些访问进行优化，有可能出现无法想象的问题，这里称为编译器的重排序。
 所以Java语言规范引入了Java内存模型，通过定义多项规则对编译器和处理器进行限制，主要针对可见性和有序性。

Java内存模型底层是怎么实现的？
  主要是通过内存屏障禁止重排序的。
  对于编译器而言，内存屏障将限制它所能做的重排序优化。
  对于处理器而言，内存屏障将会导致缓存的刷新操作。


  final :
   final修饰变量时，初衷就是告诉编译器: 这个变量生而不变，可以使劲优化。

  volatile:
   最原始的意义就是禁用CPU缓存。
    volatile int x = 0 ;  // 告诉编译器，对这个变量的读写，不能使用CPU缓存，必须从内存中读取或写入。

   Happens-Before 规则: (前面一个操作的结果对后续操作是可见的)
     这个规则约束了编译器的优化行为。

     1、程序的顺序性规则:
     一个线程中，按照程序顺序，前面的操作Happens-Before于后续的任意操作。
      程序前面对某个变量的修改一定是对后续操作可见的。
     2、volatile 变量规则:
      对一个volatile变量的写操作，Happens-Before 于后续对这个volatile 变量的读操作。
       volatile保证可见性但是不保证原子性的同步，性能往往是由于锁操作的。
     3、传递性:
      如果A Happens-Before B ，且 B Happens-Before C ，那么 A Happens-Before C 。

     4、锁:
      对一个锁的解锁 Happens-Before 于 后续对这个锁的加锁。
      实际上，在解锁的时候，JVM需要强制刷新缓存，使得当前线程所修改的内存对其他线程可见。

     5、 线程start() :
      主线程A 启动子线程 B后，子线程B能够看到主线程在启动子线程 B 前的操作。

     6、线程join() :
     主线程A 等待 子线程B完成(通过在主线程A中调用子线程B 的join())，当子线程B完成后(主线程A中 join()方法返回)，主线程能够看到子线程的操作。
