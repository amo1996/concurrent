
CPU、内存、IO设备都在不断迭代，有一个核心矛盾一直存在，就是这三者的速度差异。

为了合理利用CPU的高性能。
1 CPU增加了缓存，以均衡与内存的速度差异。
2 操作系统增加了进程、线程，以分时复用CPU，均衡CPU与IO设备的速度差异。
3 编译程序优化指令执行顺序，使缓存能够得到更加合理的利用。
但是这也是并发程序很多诡异问题的源头。

源头一  缓存导致的可见性问题:
     一个线程对共享变量的修改，另一个线程能够立刻看到，我们称为可见性。
     多核时代，每颗CPU都有自己的缓存，当多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。


源头二  线程切换带来的原子性问题:
    任务切换的时机大多数是在时间片结束的时候，我们现在基本使用的高级语言编程。一条语句往往需要多条CPU指令完成。
    例如 count+ =1 ; 需要的是三条CPU指令。
    1 将变量count从内存加载到CPU的寄存器;
    2 在寄存器中执行+1操作;
    3 最后将结果写入内存(可能写入的是CPU缓存)。

    我们把一个或者多个操作在CPU执行的过程中不被中断的特性称为原子性。但是CPU能保证的原子操作是CPU指令级别的。


源头三  编译优化带来的有序性问题:
   编译器为了优化性能，有时候会改变程序中语句的先后顺序。




